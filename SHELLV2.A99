;
;*******************************************************************
;
;**************  Original Version *********************************
;* Small/Shell: Version 1.0
;*              A command processor for North Star DOS
;*
;* Copyright    1981  J. E. Hendrix
;*              All rights reserved
;
;* Written for PDS assembler
;*************  TMS 9900 Version  *******************************************
;
;	SHELL VER 2.0.00
;	FOR THE TMS9900 SERIES COMPUTER
;	MODERN REVS	
;	01. ADDED FILENAME EXTENSION HANDLING 4 JUNE 2010
;	V2  ADDED INTERNAL COMMANDS, DIR, SAVE, ERA
;*********************************************************************
;
R0	EQU	0
R1	EQU	1
R2	EQU	2
R3	EQU	3
R4	EQU	4
R5	EQU	5
R6	EQU	6
;R7	EQU	7   CAN'T USE R7 AS IT IS RESERVED
R8	EQU	8
R9	EQU	9
R10	EQU	10
R11	EQU	11
R12	EQU	12
WP	EQU	13
R14	EQU	14
R15	EQU	15
SP	EQU	10
;
;----Define  Extended Operations
;
;	DEFINE SOME XOP'S
;
	DXOP	PUSHREG,4
	DXOP	POPREG,5	
	DXOP	CALL,6
	DXOP	RET,7
	DXOP	PUSH,8
	DXOP	POP,9
	DXOP	WHEX,10			;WRITE OUT A 16 BIT HEX VALUE
	DXOP	RHEX,11			;READ IN A 16 BIT HEX VALUE
	DXOP	WRITE,12		;WRITE CHAR IN MSB
	DXOP	READ,13			;READ CHAR IN MSB
	DXOP	MESG,14			;OUTPUT NULL TERMINATED MESSAGE
;
;
;---TPA------->0100H
;---C9EFH----->STACKP
;---CA00H----->SHELL 
;---D800H----->BDOS ORG
;---E600H-----MONITOR

;**********LOW MEMORY GLOBALS
;
;  SHELL VECTOR		080H
;  BDOS VECTOR		084H
;  COMMAND LINE POINTER		0A0H
;  COMMAND LINE SIZE		0A2H
;  SYSTEM BUFFER ADDRESS	0A4H		;ADDRESS OF SYSTEM BUFFER
;  FREE MEMORY POINTER		0A6H
;
;  SHELL VECTOR

;
SHELL:	EQU	0CA00H


	AORG	SHELL
STACKP	EQU	$-2		;STACK LOCATION

;SET LOCATION OF STACK.  SHELL ALLOCATES STACK FOR ALL PROGRAMMES
;

	JMP	INIT		;COLD START
;
;EQUATES	TABLE
;
CMDL_PTR:	EQU	0A0H		;ADDRESS OF SYSTEM COMMAND LINE
CMDL_SIZE:	EQU	0A2H		;WORD HOLDS THE LENGTH OF THE COMMAND LINE
BUFVECT: 	EQU	0A4H		;ADDRESS OF SYSTEM BUFFER
FREEMEM:	EQU	0A6H		;FREE MEMORY POINTER - USED IN MONITOR
BUFFSIZ:	EQU	512		;ADD TWO BYTES AS A SAFETY BUFFER
;
SHELLBV:	EQU	80H		;SHELL VECTORS
BDOSV:	EQU	84H		;BDOS VECTORS (Workspace vector is not used)
;
CLSZ:	EQU	64		;LENGTH OF COMMAND LINE
TPA:	EQU	0100H		;DEFAULT RUN ADDRESS
BDOS:	EQU	0D800H
TIMON:	EQU	0F000H

;
;	BDOS	FUNCTION	CALLS
;
CIN	EQU	1
COUT	EQU	2			;CONSOLE OUTPUT
SELDSK	EQU	14
RDSEQ	EQU	20
FOPEN	EQU	15
FCLOSE	EQU	16
SEARCH1	EQU	17
SEARCH2	EQU	18
ERAFIL	EQU	19
WRSEQ	EQU	21
MAKFIL	EQU	22
SETDMA	EQU	26	 		;
HDERR	EQU	0			;HARD DISK ERROR BRANCH
DOSERR	EQU	0			;DLOOK FILENAME ERROR BRACH
;
;
;---FCB	EQUATES
;
NAM	EQU	0	
FTY	EQU	11			;TYPE 
FLA	EQU	16			;FILES LOAD ADDRESS
CRN	EQU	26	 		;NEXT RECORD TO READ/WRITE 
CBN	EQU	24	 		;CURRENT BLOCK NUMBER
RELB	EQU	28			;RANDOM ACCESS RELATIVE BLOCK NUMBER
RELR	EQU	30			;RELATIVE RECORD NUMBER
FSB	EQU	12			;FILE STARTING BLOCK
FSZ	EQU	14			;FILE SIZE IN SECTORS
;
;
;------MISC.	ASSEMBLY	CONSTANTS
;
BLKSIZ	EQU	512			;DISK BLOCK SIZE
NAMSIZ	EQU	11			;DIRECTORY NAME SIZE
EXTSIZ	EQU	3			;EXTENSION SIZE
DDEN	EQU	1			;DRIVE DENSITY
DCOMR	EQU	1			;DOS READ COMMAND
PAD	EQU	0			;SMALL-VM PAD CHAR
CTLC	BYTE	03H	 		;^C
CTLX	BYTE    18H	 		;^X 
CTLS	BYTE	13H			;^S
CTLY	BYTE	19H			;^Y
CTLZ	BYTE	1AH			;^Z
SPACE	BYTE	20H			;SPACE CHAR
	BYTE	0			;ALLOWS IT TO BE USED IN MESSAGES
BS	BYTE	08H			;BACK SPACE
CR	BYTE	0DH
LF	BYTE	0AH
DEL	BYTE	07H					;DELETE CHAR
EOF	BYTE	0FFH			;END OF FILE 
COMT	BYTE	3AH	 		;COMMENT FLAG
JUMP	BYTE	'.'	 		;JUMP TO LOADED PROG
NULPARM	BYTE	'.'			;NULL PARAMETER FLAG
EXT	BYTE	'.'			;EXTENSION 
NOTE	BYTE	'_'	 		;OPERATOR NOTE FLAG
PROM	BYTE 	'%'	 		;PROMPT CHAR
SUBMARK	BYTE	'$'	 		;MARKS SYMBOLIC PARAM IN PROC FILE
SYSFILE	BYTE	'*'	 		;IDENTIFIES A SYSTEM FILE
DOSCMD	BYTE	'+'			;DOS COMMAND
CONSOLE	EQU	0			;CONSOLE DEVICE
EXEC	EQU	2			;TYPE OF EXECUTABLE FILE
PROC	EQU	5		 	;TYPE OF PROCEDURE FILE
DEFDRV	EQU	0			;DEFAULT DRIVE FOR PROC
;
;	INITIALISATION - SET UP LOCAL AND PROGRAMME WORKSPACE AND VECTORS AND THEN CALL 
;	MONITOR
;	PROGRAMMES THAT CHANGE WORKSPACE CANNOT ENTER VIA RETURN BUT MUST COME THROUGH HERE
;	HAVE COME HERE THROUGH A WARM BOOT/MONITOR AND THAT INTERRUPT VECTORS ARE SET
;
	EVEN
INIT	LIMI	0		;DISABLE INTERRUPTS
	LWPI	WORKSP		;USE LOCAL WORKSPACE
	LI	SP,STACKP		;STACK LOCATION
	MOVB	@CR,@CMDLINE	;NO AUTOBOOT AT PRESENT
	LI	R0,CMDLINE
	MOV	R0,@CMDL_PTR	;COMMAND LINE POINTER
	CLR	@CMDL_SIZE		;ZERO THE COMMAND LINE SIZE
;	LI	R0,CMDL_SIZE	;PATCH THE COMMAND LINE SIZE VECTOR
;	MOV	R0,@CMDL_SIZE_PTR
	LI	R0,MBUF		;SYSTEM BUFFER
	MOV	R0,@BUFVECT
;
; PATCH SHELL RETURN VECTOR 
;
INIT22	LI	R0,0460H		;BRANCH INSTRUCTION 
	LI	R1,RETURN		;INSERT BRANCH VECTORS	
	MOV	R0,@SHELLBV
	MOV	R1,@SHELLBV+2
;
; PATCH BDOS VECTORS - NOTE THE WORKSPACE IS NOT USED
;
	LI	R0,0460H		;BRANCH OPCODE
	LI	R1,BDOS		;ADDRESS OF BDOS IN MEMORY

	MOV	R0,@BDOSV		;BDOS BRANCH VECTOR INSTRUCTION
	MOV	R1,@BDOSV+2		;BDOS VECTOR
;
; 	PATCH FREEM MEMORY VECTORS
; 	TOP OF FREE MEMORY - RESET BY SHELL WHEN LOADING PROGS FROM DOS
;
	LI	R0,0100H		;START OF FREEMEM WHEN NO PROGRAMMES ARE LOADED
	MOV	R0,@FREEMEM
;
; NOW SIGN ON
;
	MESG	@SINON		;PRINT SIGN ON MESSAGE
	LIMI	4		;ENABLE INTERRUPTS
;
;	FALL INTO DOCMD
;
;----DO	NEXT SHELL COMMAND
;
DOCMD	MOV	@SKIPSW,R0	 	;SKIP THIS CMD?
	CLR	@SKIPSW
	MOV	R0,R0
	JNE	DOCMD2A			;YES 
	CLR	R1
	MOVB	@CMDLINE,R1
	CB	R1,@CR			;IS 1ST BYTE OF CMD A CR ? 
	JEQ	DOCMD2A	 		;YES-IGNORE CMD
CHKSYS	CI	R1,0			;(MUST USE TWO WORDS) SYS FILE?<<ALTERED AFTER BOOT>>
	JNE	DOCMD1	 		;NO 
	B	@CMDERR	 		;YES
;
;	RETURN TO TIMON ?
;
DOCMD1	CB	R1,@CTLX	 	;^X?
	JNE	DOCMDAA		 	;NO
	B	@TIMON
DOCMDAA	CB	R1,@CTLY		;^Y
	JNE	DOCMD2
;
;
;	LEADING CHAR <=SPACE ?
;
DOCMD2	CB	R1,@SPACE	 
	JH	DOCMD4			;NO
;
DOCMD2A	B	@NEXTCMD	 	;YES
;
;	JUMP TO OR LOAD PROGRAM ?
;
DOCMD4	CB	R1,@JUMP	
	JNE	DOCMD3	
	LI	R3,CMDLINE+1
	CB	*R3,@SPACE		;2ND BYTE A GRAPHIC?
	JH	DLOOK1	 		;YES,LOAD
	JMP	GOPROG	 		;NO,JUMP
;
;******************************************
;
;	DOS COMMAND
;
;********************************************
;
DOCMD3	CB	R1,@DOSCMD
	JNE	LOOK	
;
; PROCESS DOS COMMAND HERE
;
DOCMD9	;MAY USE LATER
	B	@RETURN
;	
;
;	LOOKUP NAMED FILE
;
LOOK	LI	R3,DEFDRV
	LI	R2,SELDSK
	CALL	@BDOS
	LI	R3,CMDLINE	 	;R3->FILENAME
DLOOK1	LI	R4,FCB	 	;POINT TO FCB
	LI	R2,NAMSIZ 		;NAME LENGTH
DLOOK2	CB	*R3,@SPACE
	JLE	DLOOK3	 	;NON GRAPHIC
;
;DETECT FILE EXTENSION - IF NONE ASSUME .EXE/COM
;
	CB	*R3,@EXT		;'.'?
	JNE	DLOOK5
;
;	PAD TO FILL TO EXT - ASSUME USER WILL ALWAYS TYPE IN EXTENSION IF NEEDED
;	THIS ALLOWS RUN.EXE TO BE PADDED TO 'RUN     EXE'
;
	INC	R3		;JUMP OVER '.'
	AI	R2,-EXTSIZ		;EXTENSION ARE 3 BYTES LONG
	JL	LOOKERR		;ASSUME EXT IS PART OF FILENAME
	JEQ	DLOOK7
DLOOK6	MOVB	@SPACE,*R4+ 	;PAD WITH SPACES
	DEC	R2
	JNE	DLOOK6
DLOOK7	LI	R2,EXTSIZ		;RESET TO COPY EXTENSION CHARS
DLOOK5	MOVB	*R3+,*R4+		;No
	DEC	R2
	JNE	DLOOK2	 	;KEEP GOING
	JMP	DLOOK4
DLOOK3	MOVB	@SPACE,*R4+ 	;PAD WITH SPACES
	DEC	R2
	JNE	DLOOK3
DLOOK4	CALL	@ICMD		;LOOK FOR INTERNAL COMMAND
	LI	R3,FCB	 	;SET FDC PTR
	LI	R2,SEARCH1		;SEARCH RETURNS WITH R3->DIRECTORY ENTRY
	CALL	@BDOS	 	;TRY TO FIND A FILE
	MOV	R1,R1	 	;SUCCESS ?
	JLT	LOOKERR		;NO FILES ON DISC
	LI	R2,FOPEN		;SEARCH RETURNS WITH R3->DIRECTORY ENTRY
	LI	R3,FCB
	CALL	@BDOS		;OPEN FILE
	MOV	R1,R1		;FOUND?
	JLT	LOOKERR	 	;NO
	LI	R4,FCB
	MOV	R3,R4			;COPY FCB
	MOV	@FSZ(R4),@MFSZ 		;FILE SIZE
	MOVB	@FTY(R4),R0
	SRL	R0,8
	MOV	R0,@MFTY		; 
	JEQ	LOAD			;ZERO BYPASSES CHECKS
	ANDI	R0,7	 		;MASK TYPE BITS 
	CI	R0,2			;EXECUTABLE ? 
	JEQ	LOAD	 		;YES 
	CI	R0,5	 		;PROCEDURE TYPE? 
	JNE	LOOKERR			;NO
	B	@DOPROC
LOOKERR	B	@CMDERR	 		;NO-TOO BAD
;
;	LOAD EXECUTABLE	FILE
;
LOAD	CLR	R1	 		;DISABLE PROG REENTRY
	MOVB	R1,@CMDLINE-2
	LI	R4,FCB
	MOV	@FLA(R4),R3		;GET LOAD ADDRESS
	JNE	LOAD2			;IF LOAD ADDRESS ZERO USE TPA
	LI	R3,TPA			;LOAD ADDRESS
LOAD2	MOV	R3,@LADDR
	CLR	@CRN(R4)		;BEGIN AT FIRST RECORD
LOAD0	PUSH	R3		;SAVE DMA ADDR
	LI	R2,SETDMA
	CALL	@BDOS
	LI	R2,RDSEQ 		;LOAD THE FILE
	LI	R3,FCB
	CALL	@BDOS
	POP	R3	 	;POP DMA ADDR
	CI	R1,-1		;LOOK FOR EOF
	JEQ	LOAD1	 		;
	AI	R3,BLKSIZ	 	;UP DMA
	JMP	LOAD0	 		;
LOAD1	MOV	R3,@FREEMEM		;THIS IS THE NEW FREE MEMORY POINTER
	CB	@CMDLINE,@JUMP	;JUST LOAD IT?
	JEQ	NEXTCMD	 	;YES
;
;**************************************************
;
;	JUMP TO LOADED PROGRAM
;
;***************************************************
;
GOPROG	MOV	@LADDR,@GO+2	;JUMP ADDR
	LI	R4,CMDLINE 		;?
GOLOOP	INC	R4	
	CB	*R4,@SPACE	 	;1ST CHAR <=SPACE?
	JH	GOLOOP	 	;NO
	CLR	R1	 	;TELL SMALL-VM IT'S A SHELL COMMAND
	MOVB	R1,@CMDLINE-1	;DONE
	LI	R0,SHELLBV		;RETURN ADDRESS IF NEEDED
	PUSH	R0
	STWP	WP		;GIVE THE CALLING PROGRAMME ACCESS TO THE WORKSPACE ADDRESS ( NEEDED IN SMALLC )
GO	B	@SHELLERR 		;<<THIS ADDR IS ALTERED >>
;	
; R4 = RETURN CODE		
;			
;
;	R1 IS THE RETURN CODE
;	NOTE NEED TO RESTORE WP POINTERS ETC
;
RETURN	MOVB	R1,@CMDLINE-2
	LWPI	WORKSP			;REINITIALSE WORKSPACE AND STACK POINTERS 
	LI	SP,STACKP
	MOVB	@CMDLINE-2,R1
	SRA	R1,8
	CI	R1,-1			;RETURN VIA SMALL-VM?
	JNE	NEXTCMD 		;NO
	CLR	R1
	MOVB	R1,@CMDLINE-2		;ENABLE PROGRAMME RE-ENTRY
	MOV	R1,R1	 		;IS RETURN CODE ZERO?
	JEQ	NEXTCMD			;YES
	B	@UNPROC	 		;NO,ABORT PROC CMD IF IN PROGRESS
;
;-----WHERE IS NEXT COMMAND TO BE FOUND
;
NEXTCMD	MOVB	@PROCSW,R1
	JEQ	PROMPT
	B	@PFETCH 
				 
;
;-----CONSOLE	INPUT
;
PROMPT 	MOVB	@PROM,R3		;PROMPT CHARACTER INTO MSB
	CALL	@OUTCHAR
	LI	R4,CMDLINE 		;R4=DEST PTR
	LI	R5,CLSZ			;R5=CHAR COUNTER
CINLOOP	MOV	@CONSOLE,R1	
	CALL	@INCHAR	 		; RETURN INTO MSB OF R1
	CB	R1,@BS	 		;BS?
	JEQ	RUBOUT	
	CB	R1,@DEL	 		;DEL?
	JEQ	RUBOUT	
	CB	R1,@CTLC 		;^C?
	JNE	STOWIT	 		;NO
	MOVB	@CR,R1	 		;YES (CR=0DH)
	MOVB	R1,@CMDLINE	 	;IGNORE CMD
;
;---Convert to upper case
;
STOWIT	MOV 	R1,R0
	SRL	R0,8
	CI 	R0,61H			;'a'
	JL	STOWIT2	
	CI	R0,7AH			;'z'
	JH	STOWIT2
	AI	R0,-20H			;CONVERT TO LOWER CASE
	SWPB	R0
	MOVB	R0,*R4+
	JMP	STOWIT2+2
STOWIT2	MOVB	R1,*R4+			;STORE THE CHARACTER
	DEC	R5	
	JLE	CIOERR			;NO MORE SPACE 
	CB	R1,@SPACE		;CTL CHAR?
	JHE	ECHO	 		;NO,CONTINUE
	CLR	R0
	MOVB	@CR,R1			;FORCE CR
	MOVB	R0,*R4 			;NULL TERMINATE	
ECHO	MOV	R1,R3			;ECHO CHAR
	CALL	@OUTCHAR		;RETURNS CHAR IN R1 LSB
	CLR	@SKIPSW	 		;DOSN'T ALTER FLAGS
	CB	R1,@LF	 		;OUTCHAR GENERATES AUTO LF AFTER CR
	JEQ	GODOCMD	 
	JMP	CINLOOP	
RUBOUT	CI	R5,CLSZ	
	JHE	CINLOOP	 		;CMDLINE IS EMPTY
	INC	R5	
	DEC	R4	
	PUSH	R4	 		;PUSH R4
	LI	R4,RUBMSG	
	CALL	@OUTSTR	 
	POP	R4	
	JMP	CINLOOP	
GODOCMD	LI	R0,CMDLINE
	S	R0,R4			;CALCULATE THE LENGTH OF THE COMMAND LINE USING THE POINTER IN R4
;	SWPB	R4			;CAN'T BE GREATER THAN 255
	MOV	R4,@CMDL_SIZE		;STORE CMDLINE SIZE FOR SMALL C
	B	@DOCMD	
CIOERR	B	@LINERR	

;
;*****************************************************
;	LOOK FOR INTERNAL COMMANDS, I.E. DIR, SAVE, ETC
;	FBC -> FILENAME
;
;*****************************************************
;
CMDCNT	EQU 	4		;NUMBER OF POSSIBLE INTERNAL COMMANDS
ICLIST	TEXT	"DIR"
	BYTE	0		;END
	WORD	DSKDIR		;ADDRESS
	TEXT	"SAVE"
	BYTE	0		; END
	WORD	DSKSAVE		;ADDRESS
	TEXT	"ERA"		;ERASE
	BYTE	0		; END
	WORD	ERAFILE		;ADDRESS
	TEXT	"TYPE"		;TYPE A FILE TO THE CONSOLE
	BYTE	0		; END
	WORD	TYPEFILE		;ADDRESS
	EVEN
;
;	MISC STORAGE
;
BUFPNT	WORD	2	 	;BUFFER POINTER
PAGCNT	WORD	2	 	;NO. OF PAGES TO SAVE
SADDR	WORD	2		;START ADDRESS
SWITCH	BYTE	'-'		;COMMAND LINE SWITCH
BYTSEC	EQU	512
	EVEN
;	
ICMD	LI	R1,ICLIST
	LI	R3,FCB		;NAME OF COMMAND
	LI	R5,CMDCNT	;NUMBER OF INTERNAL COMMANDS
ICMD0	CB	*R3+,*R1+
	JEQ	ICMD0
	DEC	R1		;BACK UP THE POINTER
	DEC	R3
	CB	*R3,@SPACE	;IF SPACE WE HAVE REACHED THE END OF THE FILENAME
	JH	ICMD1	 	;GRAPHIC CHARACTER, MEANS NO MATCH
	MOVB	*R1,R0		;TEST FOR END OF ENTRY
	JNE	ICMD1		;NO MATCH
;
;	MATCH HERE BRANCH TO ADDRESS
;	
	INC	R1		;MOVE TO ADDRESS FIELD
	MOVB	*R1+,R2		;MSB PART OF ADDRESS
	SWPB	R2
	MOVB	*R1+,R2
	SWPB	R2		;ADDRESS IS NOW IN R2
	POP	R0		;WE WON'T BE RETURNING SO POP RETURN ADDRESS
	B	*R2		;CALL THE COMMAND
;
ICMD1	DEC	R5		;MORE COMMANDS TO SEARCH ?
	JEQ	ICMDE
;
; NEXT INTERNAL COMMAND
;
ICMD2	MOVB	*R1+,R0		; LOOK FOR TEMINATOR
	JNE	ICMD2
	INCT	R1		;POINT TO NEXT COMMAND
	LI	R3,FCB		;R1 POINTS TO NEXT COMMAND
	JMP	ICMD0
ICMDE	RET			;RETURN 
;
;*********************************************************
;
; INTERNAL COMMAND DIR
;
;**********************************************************
;
;	MISC DEFINITIONS
;
BAR	TEXT	' : '
	BYTE	0
CRLF	BYTE	0DH,0AH,0
MNOFILE	TEXT	'NO FILES'
	BYTE	0DH,0AH,0
BYTSEC	EQU	512	 		;BYTES/SECTOR
	EVEN
CCOUNT	WORD	0			;COLUMN COUNTER
;
	EVEN
DSKDIR	LI	R0,6
	MOV	R0,@CCOUNT
	LI	R1,'?'*256		;WILD CHARACTER
	LI	R0,NAMSIZ 		;FCB COUNTER
	LI	R8,FCB	  		;
	MOV	R8,R2	 		;SAVE FCB
DSKDIR0	MOVB	R1,*R2+	 		;STORE IN FCB
	DEC	R0	 		;ANY MORE ALLOWED ?
	JNE	DSKDIR0	 		;YES
;
;	NOW SEARCH FOR FILES
;
	LI	R2,SEARCH1		;SEARCH RETURNS WITH R3->DIRECTORY ENTRY
	LI	R3,FCB
	CALL	@BDOS	 		;TRY TO FIND A FILE
	MOV	R1,R1	 		;SUCCESS ?
	JLT	NOFILE			;NO FILES ON DISC
	CALL	@PNAME			;PRINT THE NAMES	
;
;	CONTINUE
;
DSKDIR1	LI	R2,SEARCH2
	LI	R3,FCB
	CALL	@BDOS

	MOV	R1,R1
	JLT	DIREXIT
	CALL	@PNAME
	JMP	DSKDIR1
;
;********************************
;
;	PRINT THE DIRECTORY ENTRY
;
;	R3 -> CURRENT DIRECTORY ENTRY	
;
;*********************************
;
PNAME	DEC	@CCOUNT
	JNE	PNAME1
	MESG	@CRLF
	LI	R1,6
	MOV	R1,@CCOUNT
;
PNAME1	MOV	R3,R1			;DIRECTORY POINTER
	LI	R0,NAMSIZ
PNAME2	PUSH	R0
	MOVB	*R1+,R3			;PRINT NAME
	SWPB	R3			;DO PRINTS LSB
	PUSH	R1
	LI	R2,COUT
	CALL	@BDOS	
	POP	R1
	POP	R0
	DEC	R0
	JNE	PNAME2
	MOV	@CCOUNT,R0
	CI	R0,1			;IF LAST ENTRY ON LINE DONT BAR
	JEQ	PNAME3
	MESG	@BAR
PNAME3	RET
;
;
DIREXIT	MESG	@CRLF
	CLR 	R1			;SHOW RETURN NOT FROM VM
	B	@RETURN			;RETURN TO SHELL
;
NOFILE	MESG	@MNOFILE
	CLR	R1			;SHOW RETURN NOT FROM VM
	B	@CMDERR	
	
;
;*******************************************************
;
; SAVE A PROGRAMME IN MEMORY TO A FILE 
; SYNTAX
;        SAVE <NUMBER OF 512 SECTORS> <FILENAME>  <-MEMORY ADDRESS>
;
;
;******************************************************
;
;BDOSRV EQUATES	
;
CMDPTR	EQU	0A0H		;SHELL COMMAND LINE POINTER
PARSERR	B	@PARSMSG

DSKSAVE	CLR	@PAGCNT
	CLR	@BUFPNT
	LI	R8,TPA		;DEFAULT START ADDRESS
	MOV	R8,@SADDR
	LI	R8,CMDLINE
START00	CB	*R8+,@SPACE	 	;JUMP OVER 'SAVE' LOOK FOR NON VALID CHARACTERS
	JH	START00
	DEC	R8	 	;BACK UP TO 1ST CHAR
START02	CB	*R8,@CR		;EOF COMMAND?
	JEQ	PARSERR
	CB	*R8+,@SPACE		;NOW JUMP OVER SPACES
	JLE	START02
	DEC	R8
	MOV	R8,@BUFPNT		;LOOK FOR NUMBER OF SECTORS
	CALL	@ATOD	 	;CONVERT ASCII TO DEC
	MOV	R1,R1	 	;ZERO SHOWS ERROR
	JEQ	PARSERR
	MOV	R1,@PAGCNT		;SAVE AS PAGE COUNT
	MOV	@BUFPNT,R8
;
;	LOOK FOR FILE NAME
;
STRT01	CB	*R8,@CR		;EOL COMMAND?
	JEQ	PARSERR
	CB	*R8+,@SPACE 	;LOOK FOR NAME
	JLE	STRT01
	DEC	R8	 	;BACK UP
	MOV	R8,R3		;R3->NAME
	LI	R0,NAMSIZ 		;FCB COUNTER
	LI	R8,FCB	  		;
	MOVB	@SPACE,*R8		;FILL WITH SPACE
	MOV	R8,R2	 		;SAVE FCB
NAM0	CB	*R3,@SPACE	 	;END OF NAME ?
	JLE	NAM1	 	;YES
	JEQ	PARSERR
	INC	R3		;UP POINTER
	DEC	R0		;DONT STORE TOO MANY
	JLE	NAM0
	DEC	R3
	MOVB	*R3+,*R2+		;STORE IN FCB
	JMP	NAM0		;KEEP GOING
NAM1	MOV	R0,R0
	JLE	NAM2		;FCB ALREADY FULL
NAM4	MOVB	@SPACE,*R2+	 	;PAD WITH SPACES
	DEC	R0
	JNE	NAM4
;
;	LOOK FOR START ADDRESS	
;	IF EOL ENCOUNTERED USE DEFAULT TPA
;
NAM2	CB	*R3+,@SPACE		; END
	JEQ	NAM2			;KEEP LOOKING FOR NUMBER
	DEC	R3
	CB	*R3,@CR
	JEQ	NAMSRCH			;USE DEFAULT TPA
	CB	*R3+,@SWITCH		;SEE IF ANY SWITCHS ARE THERE 
	JNE	PARSERR
	MOV	R3,@BUFPNT		;FOR ATOD
	CALL	@CATOH			;SEE IF ITS LEGAL
	MOV	R1,R1			;ZERO IS AN ERROR
	JEQ	PARSERR
	MOV	R1,@SADDR		;SAVE AS START ADDRESS
;
;	USE BDOS TO SEARCH FOR FILE
;
NAMSRCH	LI	R2,SEARCH1		;SEARCH RETURNS WITH R3->DIRECTORY ENTRY
	LI	R3,FCB
	CALL	@BDOS	 		;TRY TO FIND A FILE
	MOV	R1,R1	 		;SUCCESS ?
	JLT	NAM5			;NO FILES ON DISC
NAM3	LI	R2,ERAFIL 		;PURGE IF ALREADY EXITS
	LI	R3,FCB
	CALL	@BDOS
NAM5	LI	R2,MAKFIL
	LI	R3,FCB
	CALL	@BDOS	 		;TRY TO MAKE THE FILE
;	B	@TIMON	
	MOV	R1,R1	 		;SUCCESS ?
	JLT	MKERR	 		;MAKE ERROR
	CLR	R0
	LI	R4,FCB
	MOVB	R0,@FTY(R4)		;ZERO SAYS DONT CARE
	MOV	@SADDR,R3		;START ADDRESS
	MOV	R3,@FLA(R4)		;EXECUTE ADDRESS
	MOV	R0,@CRN(R4)		;BEGIN AT FIRST RECORD
WRDATA	PUSH	R3
	LI	R2,SETDMA
	CALL	@BDOS
	LI	R2,WRSEQ
	LI	R3,FCB
	CALL	@BDOS
	POP	R3	 		;POP ADDR
	MOV	R1,R1	 		;WRITE ERROR ?
	JLT	WRITERR	 		;YES
;
;	SET FILE LIMIT
;
	CI	R3,0C000H
	JHE	LARGERR
	AI	R3,BYTSEC 		;NEXT PAGE
	DEC	@PAGCNT	 		;FINISHED ? 
	JNE	WRDATA			;YES
WRDATAC	LI	R2,FCLOSE	 	;NOW CLOSE THE FILE
	LI	R3,FCB
	CALL	@BDOS
EXIT	CLR	R1			;RETURN CODE FOR SHELL
	B	@RETURN			;NEED TO CALL SHELL INIT BECAUSE WE HAVE ALTERED WP
	
;
;*******************************************************
;
; ERASE A FILE FROM DISC 
;
;
;******************************************************
ERAPERR	B	@PARSMSG

ERAFILE	CLR	@PAGCNT
	CLR	@BUFPNT
	LI	R8,TPA			;DEFAULT START ADDRESS
	MOV	R8,@SADDR
	LI	R8,CMDLINE
ERA0	CB	*R8+,@SPACE	 	;JUMP OVER 'ERA' LOOK FOR NON VALID CHARACTERS
	JH	ERA0
	DEC	R8	 		;BACK UP TO 1ST CHAR
;
;LOOK FOR FILE NAME
;
ERA01	CB	*R8,@CR			;EOL COMMAND?
	JEQ	ERAPERR
	CB	*R8+,@SPACE 		;LOOK FOR NAME
	JLE	ERA01
	DEC	R8	 		;BACK UP
	MOV	R8,R3			;R3->NAME  
	LI	R0,NAMSIZ 		;FCB COUNTER
	LI	R8,FCB	  	;
	MOVB	@SPACE,*R8		;FILL WITH SPACE
	MOV	R8,R2	 	;SAVE FCB
ERA1	CB	*R3,@SPACE	 	;END OF NAME ?
	JLE	ERA2	 	;YES
	JEQ	ERAPERR
	INC	R3		;UP POINTER
	DEC	R0		;DONT STORE TOO MANY
	JLE	ERA1
	DEC	R3
	MOVB	*R3+,*R2+		;STORE IN FCB
	JMP	ERA1		;KEEP GOING
ERA2	MOV	R0,R0
	JLE	ERA4		;FCB ALREADY FULL
ERA3	MOVB	@SPACE,*R2+	 	;PAD WITH SPACES
	DEC	R0
	JNE	ERA3
;
;	USE BDOS TO SEARCH FOR FILE
;
ERA4	LI	R2,SEARCH1	;SEARCH RETURNS WITH R3->DIRECTORY ENTRY
	LI	R3,FCB
	CALL	@BDOS	 	;TRY TO FIND A FILE
	MOV	R1,R1	 	;SUCCESS ?
	JLT	ERAE		;NO FILES ON DISC
	LI	R2,ERAFIL 		;PURGE IF ALREADY EXITS
	LI	R3,FCB
	CALL	@BDOS
	MOV	R1,R1	 	;WRITE ERROR ?
	JLT	MKERR2	 	;YES
ERAE	CLR	R1		;RETURN CODE FOR SHELL
	B	@RETURN		;NEED TO CALL SHELL INIT BECAUSE WE HAVE ALTERED WP

;
;*****************************************************************
;
;	OUTPUT A TEXT FILE TO THE CONSOLE
;	THIS LOADS THE FILE USING .FILENAME AND THEN SENDS IT TO THE CONSOLE
;
;*****************************************************************
;
TYPEFILE:	B	@RETURN

;
;  ERROR MESSAGES
;
WRITERR	MESG	@ERRMSG4
	JMP	MKERR2
MKERR	B	@TIMON
	MESG	@ERRMSG3
	JMP	MKERR2
CLOSERR	MESG	@ERRMSG1		;IF WE DONT CLOSE UNUSED BLOCKS MAY
	JMP	MKERR2		;BE STILL ALLOCATED
PARSMSG	MESG	@ERRMSG2
	B	@NEXTCMD
LARGERR	MESG	@ERRMSG5
	JMP	MKERR2
	
MKERR2	LI	R2,FCLOSE		;TRY TO CLOSE THE FILE
	LI	R3,FCB
	CALL	@BDOS
	B	@RETURN;
;
;
; CONVERT ASCII TO DECIMAL
;
ATOD	CLR	R3	 		;PRESET VALUE
	LI	R8,10	 		;BASE 
ATOD00	MOV	@BUFPNT,R0	 		;
	MOVB	*R0,R2	 		;GET CHAR
	SRL	R2,8	 		;
	AI	R2,-'0' 		;REMOVE ASCII BIAS
	JLT	ATOD03	 		;NOT VALID
	CI	R2,10	 		;
	JLT	ATOD04	 		;OKAY
ATOD03	MOV	R3,R1	 		;ANSWER
	RET
ATOD04	MOV	R2,R0
	MOV	R3,R2
	MPY	R8,R2
	A	R0,R3
	INC	@BUFPNT 
	JMP	ATOD00
;
;	CONVERT ALPHA TO HEX
;
CATOH	CLR	R2
LOOP	MOV	@BUFPNT,R0
	CLR	R1
	MOVB	*R0,R1
	CI	R1,'0'*256
	JL	NOTHEX
	CI	R1,'9'*256
	JLE	GOTONE
	CI	R1,'A'*256
	JL	NOTHEX
	CI	R1,'F'*256
	JH	NOTHEX
	AI	R1,0900H
GOTONE	SLA	R1,4
	SRL	R1,12
;
;	DIGIT TO ACCUMULATOR
;
	SLA	R2,4
	A	R1,R2
	INC	@BUFPNT
	JMP	LOOP
;
NOTHEX	MOV	R2,R1
	RET
;
;*****************************************************
; MESSAGES
;
;****************************************************
ERRMSG1	TEXT	'--Close error'
	BYTE	0DH,0AH,0
	EVEN
ERRMSG2 TEXT	'--Parse error'
	BYTE	0DH,0AH,0
	EVEN
ERRMSG3 TEXT	'--Make error'
	BYTE	0DH,0AH,0
	EVEN
ERRMSG4 TEXT	'--Write error'
	BYTE	0DH,0AH,0
	EVEN
ERRMSG5 TEXT	'--File too large error'
	BYTE	0DH,0AH,0
	EVEN
;	
;*******************************************************
;
;	PROCEDURE INPUT
;
;******************************************************
;
PFETCH	LI	R4,CLSZ
	MOV	R4,@CMDBYTES			;BYTES LEFT IN CMDLINE
	LI	R4,CMDLINE	 		;NEXT CMDLINE DEST ADDR
	MOV	R4,@CMDADDR	
	CLR	@SUBFLAG	
;
;	IS A NEW SECTOR NEEDED?
;
PLOOP	MOV	@MCNT,R4	 		;CHARS LEFT IN BUFFER
	JNE	BUFMOVE	 		;YES, MOVE NEXT CHAR
;
;ANY	MORE	SECTORS	IN THE FILE
;
	MOV	@MFSZ,R4	
	JEQ	PROCERR1			;NO,END OF FILE
;
;READ	NEXT	SECTOR
;
	LI	R3,DEFDRV
	LI	R2,SELDSK
	CALL	@BDOS	 
	LI	R3,MBUF	 			;USE THIS BUFFER
	LI	R2,SETDMA
	CALL	@BDOS	
	LI	R3,FCB	
	LI	R2,RDSEQ	 		;READ 1 SECTOR<--
	CALL	@BDOS		 		;
	MOV	R1,R1	 			;TROUBLE ?
	JLT	PROCERR0	 		;YES
	LI	R1,BLKSIZ	 		;INIT MCNT
	MOV	R1,@MCNT	 		;
	LI	R4,MBUF	 			;INIT NEXT BUFFER ADDR
	MOV	R4,@MADDR	
	DEC	@MFSZ	 			;DECR PROC FILE SIZE(SECTORS LEFT)
	JMP	BUFMOVE	
PROCERR0	B	@SHELLERR	
PROCERR1	B	@UNPROC	
;
;-----MOVE NEXT	BYTE TO CMDLINE FROM PROC BUFFER
;
BUFMOVE	MOV	@MADDR,R4	
	MOVB	*R4+,R1	
	MOV	R4,@MADDR	
	DEC	@MCNT	 		;DECR MCNT
	PUSH	R1	 		;PUSH R1
	MOV	@SUBFLAG,R0			;PREV CHAR A SUBSTITUTION MARKER? 
	JNE	PARMSUB	 		;YES
	POP	R1			;NO 
	CB	R1,@SUBMARK	 		;THIS CHAR A SUB MARKER?
	JNE	BUFMOV2	 		;NO
	SETO	@SUBFLAG	 		;YES,SET FLAG
	JMP	PLOOP	 		;AND CONTINE
BUFMOV2	CB	R1,@EOF	 		;PDS EOF FLAG?
	JEQ	BUFMOV4			;YES,EOF
	CB	R1,@PAD	 		;SMALL-VM PAD CHAR?
	JEQ	BUFMOV4			;YES,EOF
BUFMOV3	CB	R1,@LF	 		;LF?
	JEQ	PLOOP	 		;YES,IGNORE IT
BUFPUT	MOV	@CMDADDR,R4	 	;NEXT CMDLINE ADDR
	MOVB	R1,*R4	
	CB	R1,@CR	 		;CR?
	JEQ	PEOL	 		;YES,CMD IS FETCHED
	INC	R4	
	MOV	R4,@CMDADDR	
	DEC	@CMDBYTES	 	;CMDLINE BYTES LEFT
	JEQ	MOVERR	  		;NO SPACE LEFT,ABORT PROC
	JMP	PLOOP	 		;YES,GO FOR NEXT BYTE
BUFMOV4	B	@UNPROC	
MOVERR	B	@LINERR	
;
;----PARAMETER	SUB(R1	ON	TOP OF STACK)
;
PARMSUB	CLR	@SUBFLAG	 		;CLEAR SUB FLAG
	POP	R1	 		;FETCH CAHR FOLLOWING SUBST MARKER
	PUSH	R1	 		;AND SAVE IT AGAIN
	SRL	R1,8	
	AI	R1,0FFE0H		;REDUCE ASCII BYTE TO INTEGER(-30)
	JLT	NOSUB	 		;LT ZERO
	CI	R1,10	
	JGT	NOSUB	 		;GT 9
	MOV	R1,R2	 		;PPTR OFFSET
	POP	R1	 		;WASTE TOP OF STACK
	LI	R4,PPTRS	 		;1ST PPTR ADDR
SUBLOOP	MOV	*R4,R3	 		;R3=NEXT PPTR
	JEQ	NULLPARM	
	DEC	R2	
	JGT	SUBLOOP	
;
;-PPTR	FOUND
;
SUBLOOP2	MOVB	*R3,R1	 	;FETCH NEXT PARM CHAR
	CB	@SPACE,R1	 	;END OF PARM(LE SPACE)?
	JLT	PLOOP	 		;YES,CONTINUE
	INC	R3	 		;BUMP PARM BYTE ADDR
	MOV	@CMDADDR,R4	 		;STORE BYTE IN CMDLINE
	MOVB	R1,*R4+	 		;ALSO BUMP BYTE ADDR
	MOV	R4,@CMDADDR	
	DEC	@CMDBYTES	 		;DECR BYTES LEFT IN CMDLINE
	JEQ	LINERR	 		;NO SPACE LEFT,ABORT PROC!
	JMP	SUBLOOP2	
;
;NON-NUMERIC	CHAR	FOLLOWS	SUBSTITUTION MARKER
;--TREAT	NORMAL
;
NOSUB	POP	R1	 		;RESTORE CHAR
	JMP	BUFMOV2	 		;AND CONTINUE
;
;-NO	PARAMETER	GIVEN	FOR SUBSTITUTION
;--SUB	NULL	STRING
;
NULLPARM	LI	R1,0A00H 			;FORCE BYTE TO BE SKIPPED
	JMP	BUFMOV3	
;
;----END OF PROCEDURE LINE
;
PEOL	MOVB	@CMDLINE,R1	
	CB	@COMT,R1	 		;COMMENT?
	JEQ	BPFETCH	 		;YES,IGNORE IT
	CB	@NOTE,R1	 		;OPERATOR NOTE?
	JEQ	VIEW	 		;YES, DISPLAY THE LINE
	MOV	@VSW,R1	 		;VIEW SWITCH SET?
	JEQ	CKNSW	 		;NO
VIEW	LI	R4,CMDLINE	 		;YES
	CALL	@OUTSTR	
;
CKNSW	MOV	@NSW,R1	 		;NO-EXECUTE SWITCH SET?
	JNE	BPFETCH	 		;YES,GO FOR NEXT COMMAND LINE
	MOVB	@CMDLINE,R1	 		;OPERATOR NOTE?
	CB	@NOTE,R1	
	JNE	BTDOCMD	 		;NO;PROCESS THE COMMAND LINE
	LI	R4,CMDLINE	
	INC	R4	
	CB	*R4,@NOTE			;OPERATOR RESPONCE?
	JNE	BPFETCH			;NO
WAIT	LI	R4,WAITMSG	
	CALL	@OUTSTR
	CLR	R1			;WAIT FOR A RESPONCE
	CALL	@CIN			;<---
	PUSH	R1			;ECHO CR,LF
	MOVB	@CR,R3	
	CALL	@OUTCHAR	
	POP	R1	
	CB	R1,@CR			;CR?
	JEQ	BPFETCH			;YES,CONTINE
	CB	R1,@CTLC			;^C?
	JEQ	UNPROC			;YES,ABORT PROC
	CB	R1,@CTLS			;^S?
	JNE	WAIT			;NO,KEEP WAITING
	SETO	@SKIPSW			;SET SKIP SWITCH 
BPFETCH	B	@PFETCH			;FETCH NEXT PROC COMMAND 
BTDOCMD	B	@DOCMD	
;
;-----ERROR	ROUTINES
;
CMDERR	LI	R4,CMDLINE	
	JMP	ERROUT	
LINERR	MOV	@CR,R2	
	;CALL	@OUTCHAR	
	LI	R4,LINEMSG	
	JMP	ERROUT	
PARMERR	LI	R4,PARMSG	
	JMP	ERROUT	
SHELLERR	LI	R4,SHELLMSG
	JMP	ERROUT	
HARDERR	LI	R4,HARDMSG	
	JMP	ERROUT	
NULLERR	LI	R4,NULLMSG	
	JMP	ERROUT	
NESTERR	LI	R4,NESTMSG	
	JMP	ERROUT	 
ERROUT	;PUSH	R4	
	;LI	R4,QUESTMSG
	;CALL	@OUTSTR	 
	;POP	R4	
	;CALL	@OUTSTR	 
	MESG	@QUESTMSG
	MESG	*R4
;
;-----TERMINATE	PROCEDURE	PROCESSING
;
UNPROC	CLR	@PROCSW	 		;CLEAR SWITCH 
	LI	R4,CHKSYS	 	; 
	INCT	R4	 		;POINT TO COMPARE WORD
	MOVB	@SYSFILE,*R4		;REJECT FUTURE SYS FILE REFS
	B	@RETURN	 		;RESETS SP & GOES TO PROMPT
;
;----INITIATE	PROCEDURE	PROCESSING
;
DOPROC	MOV	@PROCSW,R1	 		;ALREADY IN A PROC?
	JNE	NESTERR	 		;YES,BUT CAN'T NEST THEM
	SETO	R1	 		;NO,SET PROC SWITCH
	MOV	R1,@PROCSW	
	LI	R3,FCB			;SET PROC FDE FIELDS
	LI	R4,MNAM			;DEST 
	LI	R2,16			; 
	CALL	@BMOVE	
	CLR	R4	 		;FORCE FIRST DISK READ
	MOV	R4,@MCNT	
;
;---PARSE	PROCEDURE	PARAMETERS
;
	CLR	@VSW	 		;CLEAR VIEW SWITCH
	CLR	@NSW	 		;CLEAR NO-EXECUTE SWITHC
	LI	R4,PPTRS	 		;INIT PPADDR
	MOV	R4,@PPADDR	
	LI	R3,PBUF	 		;INIT DEST ADDR (R3)
	LI	R4,CMDLINE	 		;INIT SOURCE ADDR (R4)
	LI	R2,10	 		;MAX PARMS ALLOWED 
	CLR	R0	 		;R0 = WORD SWITCH(ZERO BETWEEN WORDS)
PARSLOOP	CLR	R1	
	MOVB	*R4+,R1			;LOAD NEXT BYTE
	CI	R1,2D00H 		;CMD LINE SWITCH(-)?
	JNE	PARS1	 		;NO
	MOV	R0,R0	 		;BEGINNING OF WORD?
	JNE	PARS0B	 		;NO,CONTINUE
	INC	R4	
	MOVB	*R4,R1	 		;TEST 3RD BYTE
	DEC	R4	
	CI	R1,2000H 		;SPACE OR CTL CHAR?
	JH	PARS0B	 		;NO,CONTINUE
	MOVB	*R4,R1	 		;TEST 2ND BYTE
	CI	R1,5600H 		;-V?
	JNE	PARS0A	 		;NO
	MOV	R1,@VSW	 		;YES,SET VIEW SWITCH
PARS0	INC	R4	 		;AND DROP SWITCH FROM THE COMMAND
	JMP	PARSLOOP	
PARS0A	CI	R1,4E00H 		;-N?
	JNE	PARS0B	 		;NO-CONTINUE
	LI	R1,2D00H 		;RESTORE CHAR
	MOV	R1,@NSW	 		;YES-SET NO EXECUTE SWITCH
	JMP	PARS0	 		;
PARS0B	LI	R1,2D00H		;RESTORE CHAR 
;
;
PARS1	MOVB	R1,*R3+	
	CI	R1,0D00H 		;END OF LINE?
	JEQ	PARSEND	 		;YES
	CI	R1,2000H 		;SPACE OR CTL CHAR?
	JH	PARS2	 		;NO
	MOV	R0,R0	 		;YES,WORD SWITCH CLEAR?
	JEQ	PARSLOOP	 		;YES,CONTINUE
	CLR	R0	 		;NO,CLEAR IT AND CONTINUE
	JMP	PARSLOOP	
;
PARS2	MOV	R0,R0	 		;IS WORD SWITCH SET?
	JNE	PARSLOOP	 		;YES,CONTINUE
	SETO	R0			;NO,SET IT
	DEC	R2	 		;WILL NEXT PARM FIT PPTRS ARRAY?
	JLT	PARMERR	 		;NO
;
;	LOAD NEXT PARM PTR
;
	PUSH	R4	 		;SOURCE
	PUSH	R3	 		;DEST
	DEC	R3	
	MOVB	*R4,R1			;2ND SOURCE CHAR<=SPACE?
	CI	R1,2000H	
	JGT	PARS3	 		;NO CAN'T BE NULL PARAMETER
	CB	*R3,@NULPARM			;1ST DEST CHAR A NULL PARAMETER?
	JNE	PARS3	 		;NO
	LI	R1,2000H 		;YES,FORCE PARM DELIMITER
	MOVB	R1,*R3	
PARS3	MOV	@PPADDR,R4	 
	MOV	R3,*R4+	
	MOV	R4,@PPADDR	
	POP	R3	 		;DEST
	POP	R4	 		;SOURCE
	JMP	PARSLOOP	
;
;-----TERMINATE	PARSING
;
PARSEND	CLR	@PPADDR			;CAP PPTRS WITH A NULL WORD
	B	@PFETCH	 		;GO PROCESS THE PROC
;
;----BLOCK	MOVE	ROUTINE
;
BMOVE	MOVB	*R3+,*R4+	
	DEC	R2	
	JNE	BMOVE	
	RET	
;
;INPUT	CHAR INTO MSB OF R1
;
INCHAR	LI	R2,CIN	 		; 
	CALL	@BDOS	 		;GET CHAR
	SWPB	R1			;PLACE CHAR IN MSB
	RET	 		;
;
;	
;   OUTPUT CHAR IN MSB OF R3 TO THE CONSOLE
;   CHARACTER RETURNED IN MSB OF R1
;   AUTO LF
;
OUTCHAR	PUSH	R3			;SAVE CHAR
	SWPB	R3			;DOS PRINTS LSB BYTE
	LI	R2,COUT	 		;
	CALL	@BDOS
	POP	R3
	CB	R3,@CR	 		;CR?
	JNE	OUT0	 		;NO
	MOVB	@LF,R3	 		;YES,GENERATE LF
	SWPB	R3			;DOS PRINTS LSB BYTE
	LI	R2,COUT
	CALL	@BDOS
	LI	R3,0D0AH		;DONE FOR SHELL
OUT0	RET	
;
;----OUTPUT	A STRING TO THE CONSOLE
;
OUTSTR	MOVB	*R4,R3
;	SRL	R3,8 
	JEQ	STR0	
	INC	R4	
	CALL	@OUTCHAR	
	JMP	OUTSTR	
STR0	RET
;
;
;----MISC	VARIABLES
;
CMDADDR	WORD	0			;CUR CMDLINE ADDR
CMDBYTES	WORD	0	 		;CMDLINE BYTES LEFT
DOSV	WORD	0	 		;DOS WARM START VECTOR
HDERRV	WORD	0	 		;DOS HARD ERROR VECTOR
DOSERRV	WORD	0	 		;DOS FILENAME ERROR VECTOR
PROCSW	WORD	0			;PROC SWITCH
SKIPSW	WORD	0			;SKIP NEXT PROC CMD
VSW	WORD	0			;VIEW SWITCH
NSW	WORD	0			;NO-EXECUTE SWITCH
SUBFLAG	WORD	0	 		;PARM SUBST FLAG
LADDR	WORD	0	;
;
;-----SHELL COMMAND LINE
;
VMENTRY	WORD	0			;CONTROLS SMALL-VM PROG REENTRY FEATURE
CMDLINE	TEXT	"*BOOT"
	BYTE	0DH,00
	BSS	CLSZ	 		;COMMAND BUFF
	EVEN

	
;
;
;----PROCEDURE	FDE & BUFFER FIELDS 
;
	EVEN
MNAM	BSS	NAMSIZ			; 	 
	BSS	2	 		;RIB
	EVEN		   
;
MFTY	WORD	0			;
MFSZ	WORD	0			;SECTORS REMAINING 
MNRR	WORD	0	 		;NRR
MCBF	WORD	0
MTSC	WORD	0
MDRV	WORD	0	 		;DRIVE #
	BSS	8			;PART OF FRI (SPARE)	
MBUF	BSS	BUFFSIZ+2			;PROC BUFFER 1 SECTOR
MCNT	WORD	0			;BYTES LEFT IN BUFFER 
MADDR	WORD	0			;CURRENT BUFFER BYTE ADDR 
;
;----MESSAGES
;
SINON	BYTE	0DH,0AH
	TEXT	'Shell Version 2.0'
	BYTE	0DH,0AH
	TEXT	'Release date 2 Oct 19'
	BYTE	0DH,0AH,0
;
NULLMSG 	BYTE 	0
;
QUESTMSG 	TEXT 	"?"
	BYTE	0
;
NESTMSG	TEXT	"Program name expected:"
	BYTE 	0DH,00
;
SHELLMSG 	TEXT 	"Shell error:"
	BYTE	0DH,00H
;
RUBMSG	BYTE	08H,20H,08H,0
;
PARMSG	TEXT	"Too many parameters:"
	BYTE	0DH,00
;
LINEMSG	TEXT	"Line too long:"
	BYTE	0DH,00
;
HARDMSG	TEXT	"HARD DISK ERROR"
	BYTE	0DH,00
;
WAITMSG	TEXT	"--waiting..."
	BYTE	0
;
;----PARAMETER	POINTERS,BUFFER	ETC.
;
	EVEN
PPTRS	BSS	22	 	;11 WORDS 
PBUF	BSS	64	 	;PARM BUUFER 
PPADDR	WORD	0		;ADDR OF CUR PARM PTR
WORKSP	BSS	32		;GENERAL SHELL WORKSPACE
FCB	BSS	36 
;
	END	
